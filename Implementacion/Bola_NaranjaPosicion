cam=webcam(2);

%tomo una captura de la camara
imagen=snapshot(cam);

%mido el tamaño del frame de la camara
framesize=size(cam);

%llamo wb a una barra de espera la cual me va a servir para poder salir del
%bucle while
wb = waitbar(0,'-','Name','Espera..','CreateCancelBtn','delete(gcbf)');


a=0;
i=2;
k=1;
j=1;
flag=0;
Centro=0
posicionAnt=0;
anguloAnt=0;
% figure(2)
t(1)=0;

%  plot(t(:),posicionAnt,'r'),xlabel('Tiempo (s)'), ylabel('posicion x');

%  figure(3)
% plot(t(:),posicionAnt,'r'),xlabel('Tiempo (s)'), ylabel('velocidad x');

%posicion(1)=-0.45;
com='COM4';

%elimino lo que este en el puerto serie
delete(instrfind({'Port'},{com}));

%Inicializo el puerto serial que utilizaré
puerto_serial=serialport(com, 2000000);

%establezco su baud rate en 9600 al igual que el arduino para que tenga una
%correcta comunicacion 
%puerto_serial.BaudRate=9600;

%aviso de error en la conexion
warning('off','MATLAB:serial:fscanf:unsuccessfulRead');

%Abro el puerto serial
fopen(puerto_serial);
puerto_serial.Timeout=0.02;

pause(0.2);

dato=0;

tic;
while 1
    t(i)=toc;
%tomo una captura de pantalla    
    img0=snapshot(cam);

    img0 = img0(180:280, 1:640, 1:3);
%convierte los valores de rojo, verde y azul de una imagen RGB en valores de luminancia (Y) y crominancia (I y Q) de una imagen NTSC.
    YIQ=rgb2ntsc(img0);
%cojo el valor de cromancia ya que los positivos es el naranja
    img=imsubtract(YIQ(:,:,2),0);
    % ---------------Filtros------------

%Filtro la imagen gris utilizando un filtro de wiener
%utilizando metodos estadisticos filtra el ruido de la imagen de 20x20
%alrededor de cada pixel sacando el valor medio
    I=wiener2(img,[10,10]);
    bw=imbinarize(I,0.15);%0.2 es mucho pero creo que 0.25 es poco

%cada pixel de salida tiene como valor la media del 3x3 de alrededor
%del aimagen binarizada    
    bw=medfilt2(bw);

%Realiza una erosion de las imagenes blancas seguido de una dilatación con
%forma de disco de valor 1
    bw=imopen(bw,strel('disk',1)); %el valor de 1 creo que es pequeño, deberia aumentarlo
    
%elimina las areas cuyos pixeles conjuntos sean menores a 1000
    bw=bwareaopen(bw,150);

%Rellena de 1 todos aquellos 0 encerrados por 1
    bw=imfill(bw,'holes');

%devuelve la matriz L con diferenciacion entre los distintos objetos N
%la matriz L es una matriz de tamaño de la imagen binarizada pero con
%enteros siendo: de valor 0 el fonde, de valor 1 el objeto 1, de valor 2
%el objeto 2...
    [L,N]=bwlabel(bw);


    %-----------------regionprops------------------
            % [B,L] = bwboundaries(I,'noholes');
 % mide diferentes propiedades, segun tu le digas, de la matriz de
 % etiquetas   
     prop=regionprops(L, 'Area', 'Centroid', 'Circularity');
    %----------------------------------------------
%muestra la matriz binarizada y con los filtros correspondientes
% figure(1)
  %  imshow(bw);

%realiza un bucle donde comprueba que el objeto correspondiente
  %mostrado es aproximadamente un circulo y muestra su centroide en la
  %pantalla de 640x400   

    for n=1:N
% obtener centroide
        c=round(prop(n).Centroid); 

%obtener cuanto se aproxima a un circulo        
        Circulo=round(prop(n).Circularity);

        if Circulo>0.95 && t(i)>2   
           
%Si detecta un circulo es la esfera, por tanto entra en el bucle de control
%resolucion (640px)
if flag==0
      Centro=c(1);
      flag=1;
end

Pos=c(1)-Centro; 


%%----------------------ruido blanco camara--------------
    % ruidoBlancoCamara(i)=5*(640/100)*(rand-0.5); % +-5 porciento de ruido
    % Pos=Pos+ruidoBlancoCamara(i);
%--------------------------------------------------------

posicion(i)=Pos*(0.4/320);
velocidad(i)=(posicion(i)-posicion(i-1))/(t(i)-t(i-1));


%_________________LAZO DE CONTROL POSICION________________________

giro=EspacioEstadoPosicion(posicion(i),velocidad(i),K,REF);

%________________________________________________________________


%----------------------Giro Posicion Serial----------------------
           
            % %%_____ruido blanco posicion____
            %     ruidoBlancoPos(i)=5*(8000/100)*(rand-0.5);
            %     giro=giro+ruidoBlancoPos(i); % +-5 porciento de ruido
            % %_________________________________
T0(i)=toc;
            pasos(i)=giro*(8000/(2*pi));
            pasosStr= num2str(pasos(i));
            write(puerto_serial,pasosStr,"int8");
            
        
            T1(i)=toc;
            Ang=readline(puerto_serial);
            T2(i)=toc;
            if isempty(Ang)
                if isempty(AnguloMot(i-1))
                    AnguloMot(i)=0;
                   
                else
                    AnguloMot(i)=AnguloMot(i-1);
                    a=a+1;
                end
            else
                AnguloMot(i)=str2num(Ang);
            end
            
            
            
           
%------------------------------------------------------

posicionAnt=posicion(i-1);

% anguloAnt=angulo;
        end
    end
 %cuadro para poder candelar el bucle while 1
%____________________________________________________    
   if ~ishandle(wb)
      if length(t)>length(posicion)
        posicion(i)=0;
      end
      if length(t)>length(AnguloMot)
        AnguloMot(i)=0;
      end

      if length(t)>length(pasos)
        pasos(i)=0;
      end

      if length(t)>length(velocidad)
        velocidad(i)=0;
      end
       % if length(t)>length(ruidoBlancoCamara)
       %  ruidoBlancoCamara(i)=0;
       % end

       % if length(t)>length(ruidoBlancoPos)
       %  ruidoBlancoPos(i)=0;
       % end
       


    t=t-2;
    figure(1);
    plot(t(:),posicion(:),'r');
   xlabel('Tiempo (s)');
   ylabel('Posición esfera');
title("Posición real de la esfera respecto al tiempo");

    figure(2); 
plot(t(:),velocidad(:),'r');
xlabel('Tiempo (s)');
   ylabel('Velocidad esfera');
title("Velocidad de la esfera respecto al tiempo");

      figure(3);  
    plot(t(:),AnguloMot(:),'r');
    hold on 
    plot(t(:),pasos(:),'b');
    xlabel('Tiempo (s)');
   ylabel('Posición Motor');
title("Diferencia entre numero de pasos ideal y real");

        break
    else
        %waitbar(i/10,wb,['num: '  num2str(i)]);
    end
%_____________________________________________________
%numero de iteraciones
    i=i+1;
end
clear puerto_serial;
clear cam;
